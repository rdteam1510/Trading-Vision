{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeBreakpointsBase = computeBreakpointsBase;\nexports.createEmptyBreakpointObject = createEmptyBreakpointObject;\nexports.default = void 0;\nexports.handleBreakpoints = handleBreakpoints;\nexports.mergeBreakpointsInOrder = mergeBreakpointsInOrder;\nexports.removeUnusedBreakpoints = removeUnusedBreakpoints;\nexports.resolveBreakpointValues = resolveBreakpointValues;\nexports.values = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _utils = require(\"@mui/utils\");\n\nvar _merge = _interopRequireDefault(require(\"./merge\")); // The breakpoint **start** at this value.\n// For instance with the first breakpoint xs: [xs, sm[.\n\n\nconst values = {\n  xs: 0,\n  // phone\n  sm: 600,\n  // tablet\n  md: 900,\n  // small laptop\n  lg: 1200,\n  // desktop\n  xl: 1536 // large screen\n\n};\nexports.values = values;\nconst defaultBreakpoints = {\n  // Sorted ASC by size. That's important.\n  // It can't be configured as it's used statically for propTypes.\n  keys: ['xs', 'sm', 'md', 'lg', 'xl'],\n  up: key => `@media (min-width:${values[key]}px)`\n};\n\nfunction handleBreakpoints(props, propValue, styleFromPropValue) {\n  const theme = props.theme || {};\n\n  if (Array.isArray(propValue)) {\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    return propValue.reduce((acc, item, index) => {\n      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);\n      return acc;\n    }, {});\n  }\n\n  if (typeof propValue === 'object') {\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    return Object.keys(propValue).reduce((acc, breakpoint) => {\n      // key is breakpoint\n      if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {\n        const mediaKey = themeBreakpoints.up(breakpoint);\n        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);\n      } else {\n        const cssKey = breakpoint;\n        acc[cssKey] = propValue[cssKey];\n      }\n\n      return acc;\n    }, {});\n  }\n\n  const output = styleFromPropValue(propValue);\n  return output;\n}\n\nfunction breakpoints(styleFunction) {\n  const newStyleFunction = props => {\n    const theme = props.theme || {};\n    const base = styleFunction(props);\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    const extended = themeBreakpoints.keys.reduce((acc, key) => {\n      if (props[key]) {\n        acc = acc || {};\n        acc[themeBreakpoints.up(key)] = styleFunction((0, _extends2.default)({\n          theme\n        }, props[key]));\n      }\n\n      return acc;\n    }, null);\n    return (0, _merge.default)(base, extended);\n  };\n\n  newStyleFunction.propTypes = process.env.NODE_ENV !== 'production' ? (0, _extends2.default)({}, styleFunction.propTypes, {\n    xs: _propTypes.default.object,\n    sm: _propTypes.default.object,\n    md: _propTypes.default.object,\n    lg: _propTypes.default.object,\n    xl: _propTypes.default.object\n  }) : {};\n  newStyleFunction.filterProps = ['xs', 'sm', 'md', 'lg', 'xl', ...styleFunction.filterProps];\n  return newStyleFunction;\n}\n\nfunction createEmptyBreakpointObject() {\n  let breakpointsInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _breakpointsInput$key;\n\n  const breakpointsInOrder = breakpointsInput == null ? void 0 : (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {\n    const breakpointStyleKey = breakpointsInput.up(key);\n    acc[breakpointStyleKey] = {};\n    return acc;\n  }, {});\n  return breakpointsInOrder || {};\n}\n\nfunction removeUnusedBreakpoints(breakpointKeys, style) {\n  return breakpointKeys.reduce((acc, key) => {\n    const breakpointOutput = acc[key];\n    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;\n\n    if (isBreakpointUnused) {\n      delete acc[key];\n    }\n\n    return acc;\n  }, style);\n}\n\nfunction mergeBreakpointsInOrder(breakpointsInput) {\n  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);\n\n  for (var _len = arguments.length, styles = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    styles[_key - 1] = arguments[_key];\n  }\n\n  const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => (0, _utils.deepmerge)(prev, next), {});\n  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);\n} // compute base for responsive values; e.g.,\n// [1,2,3] => {xs: true, sm: true, md: true}\n// {xs: 1, sm: 2, md: 3} => {xs: true, sm: true, md: true}\n\n\nfunction computeBreakpointsBase(breakpointValues, themeBreakpoints) {\n  // fixed value\n  if (typeof breakpointValues !== 'object') {\n    return {};\n  }\n\n  const base = {};\n  const breakpointsKeys = Object.keys(themeBreakpoints);\n\n  if (Array.isArray(breakpointValues)) {\n    breakpointsKeys.forEach((breakpoint, i) => {\n      if (i < breakpointValues.length) {\n        base[breakpoint] = true;\n      }\n    });\n  } else {\n    breakpointsKeys.forEach(breakpoint => {\n      if (breakpointValues[breakpoint] != null) {\n        base[breakpoint] = true;\n      }\n    });\n  }\n\n  return base;\n}\n\nfunction resolveBreakpointValues(_ref) {\n  let {\n    values: breakpointValues,\n    breakpoints: themeBreakpoints,\n    base: customBase\n  } = _ref;\n  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);\n  const keys = Object.keys(base);\n\n  if (keys.length === 0) {\n    return breakpointValues;\n  }\n\n  let previous;\n  return keys.reduce((acc, breakpoint, i) => {\n    if (Array.isArray(breakpointValues)) {\n      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];\n      previous = i;\n    } else {\n      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous] || breakpointValues;\n      previous = breakpoint;\n    }\n\n    return acc;\n  }, {});\n}\n\nvar _default = breakpoints;\nexports.default = _default;","map":{"version":3,"sources":["D:/AUT/4thYear/COMP703_RDProject/Github/SourceCode/tradingvision/node_modules/@mui/system/breakpoints.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","computeBreakpointsBase","createEmptyBreakpointObject","default","handleBreakpoints","mergeBreakpointsInOrder","removeUnusedBreakpoints","resolveBreakpointValues","values","_extends2","_propTypes","_utils","_merge","xs","sm","md","lg","xl","defaultBreakpoints","keys","up","key","props","propValue","styleFromPropValue","theme","Array","isArray","themeBreakpoints","breakpoints","reduce","acc","item","index","breakpoint","indexOf","mediaKey","cssKey","output","styleFunction","newStyleFunction","base","extended","propTypes","process","env","NODE_ENV","object","filterProps","breakpointsInput","_breakpointsInput$key","breakpointsInOrder","breakpointStyleKey","breakpointKeys","style","breakpointOutput","isBreakpointUnused","length","emptyBreakpoints","styles","mergedOutput","prev","next","deepmerge","breakpointValues","breakpointsKeys","forEach","i","customBase","previous","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeBreakpointsBase = computeBreakpointsBase;\nexports.createEmptyBreakpointObject = createEmptyBreakpointObject;\nexports.default = void 0;\nexports.handleBreakpoints = handleBreakpoints;\nexports.mergeBreakpointsInOrder = mergeBreakpointsInOrder;\nexports.removeUnusedBreakpoints = removeUnusedBreakpoints;\nexports.resolveBreakpointValues = resolveBreakpointValues;\nexports.values = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _utils = require(\"@mui/utils\");\n\nvar _merge = _interopRequireDefault(require(\"./merge\"));\n\n// The breakpoint **start** at this value.\n// For instance with the first breakpoint xs: [xs, sm[.\nconst values = {\n  xs: 0,\n  // phone\n  sm: 600,\n  // tablet\n  md: 900,\n  // small laptop\n  lg: 1200,\n  // desktop\n  xl: 1536 // large screen\n\n};\nexports.values = values;\nconst defaultBreakpoints = {\n  // Sorted ASC by size. That's important.\n  // It can't be configured as it's used statically for propTypes.\n  keys: ['xs', 'sm', 'md', 'lg', 'xl'],\n  up: key => `@media (min-width:${values[key]}px)`\n};\n\nfunction handleBreakpoints(props, propValue, styleFromPropValue) {\n  const theme = props.theme || {};\n\n  if (Array.isArray(propValue)) {\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    return propValue.reduce((acc, item, index) => {\n      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);\n      return acc;\n    }, {});\n  }\n\n  if (typeof propValue === 'object') {\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    return Object.keys(propValue).reduce((acc, breakpoint) => {\n      // key is breakpoint\n      if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {\n        const mediaKey = themeBreakpoints.up(breakpoint);\n        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);\n      } else {\n        const cssKey = breakpoint;\n        acc[cssKey] = propValue[cssKey];\n      }\n\n      return acc;\n    }, {});\n  }\n\n  const output = styleFromPropValue(propValue);\n  return output;\n}\n\nfunction breakpoints(styleFunction) {\n  const newStyleFunction = props => {\n    const theme = props.theme || {};\n    const base = styleFunction(props);\n    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;\n    const extended = themeBreakpoints.keys.reduce((acc, key) => {\n      if (props[key]) {\n        acc = acc || {};\n        acc[themeBreakpoints.up(key)] = styleFunction((0, _extends2.default)({\n          theme\n        }, props[key]));\n      }\n\n      return acc;\n    }, null);\n    return (0, _merge.default)(base, extended);\n  };\n\n  newStyleFunction.propTypes = process.env.NODE_ENV !== 'production' ? (0, _extends2.default)({}, styleFunction.propTypes, {\n    xs: _propTypes.default.object,\n    sm: _propTypes.default.object,\n    md: _propTypes.default.object,\n    lg: _propTypes.default.object,\n    xl: _propTypes.default.object\n  }) : {};\n  newStyleFunction.filterProps = ['xs', 'sm', 'md', 'lg', 'xl', ...styleFunction.filterProps];\n  return newStyleFunction;\n}\n\nfunction createEmptyBreakpointObject(breakpointsInput = {}) {\n  var _breakpointsInput$key;\n\n  const breakpointsInOrder = breakpointsInput == null ? void 0 : (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {\n    const breakpointStyleKey = breakpointsInput.up(key);\n    acc[breakpointStyleKey] = {};\n    return acc;\n  }, {});\n  return breakpointsInOrder || {};\n}\n\nfunction removeUnusedBreakpoints(breakpointKeys, style) {\n  return breakpointKeys.reduce((acc, key) => {\n    const breakpointOutput = acc[key];\n    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;\n\n    if (isBreakpointUnused) {\n      delete acc[key];\n    }\n\n    return acc;\n  }, style);\n}\n\nfunction mergeBreakpointsInOrder(breakpointsInput, ...styles) {\n  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);\n  const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => (0, _utils.deepmerge)(prev, next), {});\n  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);\n} // compute base for responsive values; e.g.,\n// [1,2,3] => {xs: true, sm: true, md: true}\n// {xs: 1, sm: 2, md: 3} => {xs: true, sm: true, md: true}\n\n\nfunction computeBreakpointsBase(breakpointValues, themeBreakpoints) {\n  // fixed value\n  if (typeof breakpointValues !== 'object') {\n    return {};\n  }\n\n  const base = {};\n  const breakpointsKeys = Object.keys(themeBreakpoints);\n\n  if (Array.isArray(breakpointValues)) {\n    breakpointsKeys.forEach((breakpoint, i) => {\n      if (i < breakpointValues.length) {\n        base[breakpoint] = true;\n      }\n    });\n  } else {\n    breakpointsKeys.forEach(breakpoint => {\n      if (breakpointValues[breakpoint] != null) {\n        base[breakpoint] = true;\n      }\n    });\n  }\n\n  return base;\n}\n\nfunction resolveBreakpointValues({\n  values: breakpointValues,\n  breakpoints: themeBreakpoints,\n  base: customBase\n}) {\n  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);\n  const keys = Object.keys(base);\n\n  if (keys.length === 0) {\n    return breakpointValues;\n  }\n\n  let previous;\n  return keys.reduce((acc, breakpoint, i) => {\n    if (Array.isArray(breakpointValues)) {\n      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];\n      previous = i;\n    } else {\n      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous] || breakpointValues;\n      previous = breakpoint;\n    }\n\n    return acc;\n  }, {});\n}\n\nvar _default = breakpoints;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}